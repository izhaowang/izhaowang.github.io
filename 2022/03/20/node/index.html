<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="三种主流的 node  程序 web应用程序： 提供单页面应用的简单程序， REST微服务以及全栈的web应用  命令行工具： npm、 Gulp、 webpack  后台程序： 后台服务、比如PM2   以及桌面程序：Electorn 框架写的软件   module.exports 和 exportsCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的e">
<meta property="og:type" content="article">
<meta property="og:title" content="node">
<meta property="og:url" content="http://example.com/2022/03/20/node/index.html">
<meta property="og:site_name" content="旺旺小小酥">
<meta property="og:description" content="三种主流的 node  程序 web应用程序： 提供单页面应用的简单程序， REST微服务以及全栈的web应用  命令行工具： npm、 Gulp、 webpack  后台程序： 后台服务、比如PM2   以及桌面程序：Electorn 框架写的软件   module.exports 和 exportsCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的e">
<meta property="og:locale">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210527220512887.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210527221209462.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528012917550.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528013137440.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528013152023.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210529232332631.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210529232144682.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210530161502955.png">
<meta property="og:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210530163631713.png">
<meta property="article:published_time" content="2022-03-20T06:23:33.000Z">
<meta property="article:modified_time" content="2023-03-02T16:26:45.849Z">
<meta property="article:author" content="zhaowang">
<meta property="article:tag" content="node.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210527220512887.png">

<link rel="canonical" href="http://example.com/2022/03/20/node/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>node | 旺旺小小酥</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">旺旺小小酥</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">路虽远，行则至</p>
      <a>
        <img class="custom-logo-image" src="/uploads/custom-logo.jpg" alt="旺旺小小酥">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="zhaowang">
      <meta itemprop="description" content="病了就要吃药">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旺旺小小酥">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          node
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-20 14:23:33" itemprop="dateCreated datePublished" datetime="2022-03-20T14:23:33+08:00">2022-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-03 00:26:45" itemprop="dateModified" datetime="2023-03-03T00:26:45+08:00">2023-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E6%9C%8D%E5%8A%A1%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web服务端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="三种主流的-node-程序"><a href="#三种主流的-node-程序" class="headerlink" title="三种主流的 node  程序"></a>三种主流的 node  程序</h1><ol>
<li><p>web应用程序： 提供单页面应用的简单程序， REST微服务以及全栈的web应用</p>
</li>
<li><p>命令行工具： npm、 Gulp、 webpack</p>
</li>
<li><p>后台程序： 后台服务、比如PM2  </p>
<p>以及桌面程序：Electorn 框架写的软件</p>
</li>
</ol>
<h2 id="module-exports-和-exports"><a href="#module-exports-和-exports" class="headerlink" title="module.exports 和 exports"></a>module.exports 和 exports</h2><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<ol>
<li><p>module.exports 级别高于 exports</p>
</li>
<li><p>如果exports和module.exports 指向不同的内存地址时，应该以module.exports 的结果为准； </p>
<p>因为正常情况（下图）exports是modules.exports 都是本来都是指向相同内存地址； 这个内存地址指向同一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span> = name</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210527220512887.png" alt="image-20210527220512887"></p>
<p>如果你改变了 exports 的引用将他设置为另一个对象 或者将 module.exports 设置为另一个对象， 应该以module.exports的对象为准</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">  name : name <span class="comment">// 这准写法以module.exports 为准 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">cname</span>: name <span class="comment">// 这里导出的是对象，里面只有cname</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210527221209462.png" alt="image-20210527221209462"></p>
</li>
</ol>
<h2 id="模块查找原则"><a href="#模块查找原则" class="headerlink" title="模块查找原则"></a>模块查找原则</h2><p>模块既可以是一个文件，也可以是包含一个或多个文件的目录， </p>
<p>如果模块是一个目录， node通常会在这个目录下找一个index.js 的文件作为文件的入口（<em><strong>这个默认值也可重写， 在package.json 中修改main 自动</strong></em>）</p>
<p>node 以同步的方法去找模块， 定位到模块并加载文件中的内容， node 查找文件的顺序是  </p>
<ol>
<li><p>require(‘.&#x2F;find.js’) 和 require(‘.&#x2F;find’)区别 ***这里是都有.&#x2F; **</p>
<p>require(‘.&#x2F;find.js’); 去当前路径找 find.js 文件</p>
<p>require(‘.&#x2F;find’) ：</p>
<ul>
<li>先去找这个路径的 find.js 文件</li>
<li>如果没有找到find.js文件， 那么就找find 的文件夹</li>
<li>如果找到了find的文件夹 ， 再找index.js；如果找到就执行，如果没有找到， 就去 find 文件夹下找package.json 文件中找main 选择的入口文件</li>
<li>如果找到知道的入口文件不存在或者没有入口文件就会报错， 模块没有找到</li>
</ul>
</li>
<li><p>requires(‘find’) 区别  *** 注意这里是没有路径，也没有后缀名，只写了模块名字  ， 此时node.js 会当做这个 是系统模块**  </p>
<ol>
<li><p>（先找系统模块： require(‘fs’)  require(‘http’)， 如果没有</p>
</li>
<li><p>然后是当前目录， node_modules 文件夹中查找</p>
</li>
<li><p>首先查看是否有改名字的JS 文件</p>
</li>
<li><p>再看是否有改名字的文件夹， 改文件夹下里面是否有index.js， 如果没有继续</p>
</li>
<li><p>查找 package.json 文件 的 main 选项， 查看入口文件， 如果没有</p>
</li>
<li><p>查找父级文件（重复2-5）</p>
</li>
<li><p>看模块在当前目录下的node_modules 中吗  在返回 ；不在继续</p>
</li>
<li><p>尝试进入父目录 重复 4-6； 如果父目录不存在</p>
</li>
<li><p>模块在环境变量NODE_PATH 指定的目录下吗 在返回 ； 不在抛出异常</p>
</li>
</ol>
</li>
</ol>
<h2 id="require方法是同步方法-所以一般写在文件顶部"><a href="#require方法是同步方法-所以一般写在文件顶部" class="headerlink" title="require方法是同步方法 所以一般写在文件顶部"></a><em><strong>require方法是同步方法 所以一般写在文件顶部</strong></em></h2><h2 id="node会把模块作为对象缓存起来。-如果两个文件引入了相同的模块，第一个require会把模块返回的数据存在内存中，-这样第二个require就不在去访问和计算源文件了。"><a href="#node会把模块作为对象缓存起来。-如果两个文件引入了相同的模块，第一个require会把模块返回的数据存在内存中，-这样第二个require就不在去访问和计算源文件了。" class="headerlink" title="node会把模块作为对象缓存起来。 如果两个文件引入了相同的模块，第一个require会把模块返回的数据存在内存中， 这样第二个require就不在去访问和计算源文件了。"></a>node会把模块作为对象缓存起来。 如果两个文件引入了相同的模块，第一个require会把模块返回的数据存在内存中， 这样第二个require就不在去访问和计算源文件了。</h2><h2 id="异步编程技术"><a href="#异步编程技术" class="headerlink" title="异步编程技术"></a>异步编程技术</h2><p>  前端中异步， 鼠标点击的后回调 就是异步</p>
<p>  服务端异步， 事件发生时的响应， node 世界中流行两种响应： 回调和事件监听。</p>
<ol>
<li>回调 通常用来定义一次性事件响应的逻辑。 比如数据库查询的回调</li>
<li>事件监听器 其本质也是一个回调， 不同的是 它跟一个实体事件相关联，比如 鼠标点击就是一个事件， 需要事件监听器 去监听点击事件，</li>
</ol>
<p><em><strong>事件发射器</strong></em>： 一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；)</p>
<ol>
<li><p>用事件发射器处理重复性事件： HTTP 服务器， TCP服务器 和流，都做成了事件发射器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&#x27;net&#x27;);</span><br><span class="line">const server = net.createServer(socket =&gt; &#123;</span><br><span class="line">   socket.on(&#x27;data&#x27;, data =&gt; &#123; // 这里使用了*** on ***进行重复性事件回调</span><br><span class="line">   socket.write(data)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;).listen(8888) </span><br></pre></td></tr></table></figure>
</li>
<li><p>响应一次性事件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&#x27;net&#x27;);</span><br><span class="line">   const server = net.createServer(socket =&gt; &#123;</span><br><span class="line">      socket.once(&#x27;data&#x27;, data =&gt; &#123; // 这里使用了***once*** 进行重复性事件回调</span><br><span class="line">      socket.write(data)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;).listen(8888) </span><br></pre></td></tr></table></figure>

<h2 id="事件发射器-一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；"><a href="#事件发射器-一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；" class="headerlink" title="事件发射器  一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；)"></a>事件发射器  一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；)</h2><ol>
<li><p>语法 </p>
<ul>
<li>*** 首先引入events模块**</li>
<li>*** 通过new 调用 events模块中的EventEmitter静态方法去创建发射器实例对象**</li>
</ul>
<ol>
<li>实操</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   //event.js 文件</span><br><span class="line">var EventEmitter = require(&#x27;events&#x27;).EventEmitter; </span><br><span class="line">var event = new EventEmitter(); // 创建事件发射器的实例对象</span><br><span class="line">event.on(&#x27;some_event&#x27;, function() &#123; // 通过 on 去订阅一个事件的逻辑</span><br><span class="line">   console.log(&#x27;some_event 事件触发&#x27;); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(function() &#123;  // 通过emit 去触发这个事件</span><br><span class="line">   event.emit(&#x27;some_event&#x27;); </span><br><span class="line">&#125;, 1000); </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="fs-文件的系统模块"><a href="#fs-文件的系统模块" class="headerlink" title="fs 文件的系统模块"></a>fs 文件的系统模块</h1><ol>
<li><p>文件的读取 readFile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">fs.readFile(文件路径，[文件读取的编码]， callback)</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">fs.writeFile(文件的路径， &#x27;数据&#x27;， callback)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h1><ol>
<li><p>路径拼接api ： 在不同的操作系统中 系统路径的分隔符是不一样的</p>
<p>windows 上是 &#x2F;  或者 \</p>
<p>linux 只有 &#x2F; （linux系统通常被用作网站的服务器）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> finialPath = path.<span class="title function_">join</span>(<span class="string">&#x27;路径1&#x27;</span>, <span class="string">&#x27;路径2&#x27;</span>, <span class="string">&#x27;路径3&#x27;</span>)</span><br><span class="line"><span class="comment">// finialPath: &#x27;路径1\路径2\路径3&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相对路径绝对路径</p>
<p>相对路径  ‘.&#x2F;a.js’;</p>
<p>绝对路径 __dirname 来获取 当前文件的绝对路径 （绝对路径使用较多）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);let finialPath = path(__dirname, &#x27;a.js&#x27;);// finialPath： &#x27;当前文件的绝对路径/a.js&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="http-模块-去HTTP协议查看"><a href="#http-模块-去HTTP协议查看" class="headerlink" title="http 模块 去HTTP协议查看"></a>http 模块 去HTTP协议查看</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);http.createServer((req, res) =&gt; &#123;	// req	res.end(&#x27;hello world&#x27;)&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="url-模块-处理url地址-去报文get请求参数查看"><a href="#url-模块-处理url地址-去报文get请求参数查看" class="headerlink" title="url 模块 处理url地址 去报文get请求参数查看"></a>url 模块 处理url地址 去报文get请求参数查看</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&#x27;url&#x27;);url.parse() // 解析请求地址</span><br></pre></td></tr></table></figure>



<h1 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h1><p>nodemon 是一个名利行工具，用以辅助项目开发。</p>
<p>在nodejs中，每次修改文件都要在命令行中重新执行该文件，非常繁琐。</p>
<p>nodemon用以在修改文件后直接可以看到修改后的效果，不需要</p>
<p>使用步骤 </p>
<ol>
<li>全局瞎子 npm install nodemon -g  （在管理员权限运行）</li>
<li>在命令行中 用nodemon命令代替node 执行</li>
</ol>
<h1 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h1><p>npm 默认下载地址再国外， 国内下载速度慢</p>
<p>nrm 是可以切换下载地址的第三方工具</p>
<ol>
<li>npm install nrm -g </li>
<li>nrm ls （查看下载地址）</li>
<li>nrm use taobao 即可</li>
</ol>
<h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><h2 id="gulp-基于node-平台开发的前端构建工具"><a href="#gulp-基于node-平台开发的前端构建工具" class="headerlink" title="gulp 基于node 平台开发的前端构建工具"></a>gulp 基于node 平台开发的前端构建工具</h2><p>将机械化操作编写成任务， 我们想要执行机械化操作去 执行命令行 命令任务就可以自动执行， 不需要程序员手动操作</p>
<p>gulp 能做什么</p>
<p>​	项目上线 html  js css 文件压缩</p>
<p>​	语法转化 es6 、 less</p>
<p>​    公共文件抽离</p>
<p>​    修改文件是 浏览器启动自动刷新</p>
<h3 id="gulp-使用"><a href="#gulp-使用" class="headerlink" title="gulp 使用"></a>gulp 使用</h3><ol>
<li><p>使用 npm install gulp  下载库文件</p>
</li>
<li><p>在项目根目录下建立 gulpfile.js 文件</p>
</li>
<li><p>重构项目的文件夹结构 src目录下放置源代码文件 dist 目录下放置构建后的文件</p>
</li>
<li><p>gulpfile.js 编写任务</p>
<p>*<strong>Gulp中的方法</strong></p>
<ul>
<li><p>gulp.src(‘文件路径’) 获取任务要处理的文件</p>
</li>
<li><p>gulp.dest(‘输出文件路径’) 输出文件</p>
</li>
<li><p>gulp.task(‘任务名称’， 回调函数) 建立gulp任务</p>
</li>
<li><p>gulp.watch() 监控文件的变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 引入gulpconst gulp = require(&#x27;gulp&#x27;);const path = require(&#x27;path&#x27;);// 使用gulp.task()建立任务, 任务名称是fitstgulp.task(&#x27;first&#x27;, () =&gt; &#123;	// 要处理的文件	gulp.src(path.join(__dirname, &#x27;/src/css/base.css&#x27;))	// 将处理后的文件输出到dist目录	.pipe(gulp.dest(&#x27;./dist/css&#x27;))&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>命令行工具中执行任务</p>
<p>*** 怎样去执行gulp的任务？  用node 命令是执行整个文件，我们要下载gulp-cli 去执行gulp的 first 任务**</p>
</li>
<li><p>下载命令行工具 npm i gulp-cli -g</p>
</li>
<li><p>gulp 空格 然后是任务名称  如 gulp first</p>
</li>
</ol>
<h2 id="gulp插件去实现文件的合并压缩功能"><a href="#gulp插件去实现文件的合并压缩功能" class="headerlink" title="gulp插件去实现文件的合并压缩功能"></a>gulp插件去实现文件的合并压缩功能</h2><p>由于gulp只有基础的5个方法，如果要实现一些辅助的操作，需要用到gulp插件</p>
<ul>
<li>gulp-htmlmin: html  文件压缩</li>
<li>gulp-csso: 压缩css</li>
<li>gulp-babel: js语法转化</li>
<li>gulp-less: less 语法转化</li>
<li>gulp-uglify： 压缩混淆js代码</li>
<li>gulp-file-include: 公共文件内容抽取</li>
<li>browsersync 浏览实时同步</li>
</ul>
<p>*<strong>使用方法</strong></p>
<ol>
<li><p>下载插件 如 npm install gulp-htmlmin</p>
</li>
<li><p>引用</p>
</li>
<li><p>调用</p>
<h3 id="压缩html文件-gulp-htmlmin"><a href="#压缩html文件-gulp-htmlmin" class="headerlink" title="压缩html文件   gulp-htmlmin"></a>压缩html文件   gulp-htmlmin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 引入gulpconst gulp = require(&#x27;gulp&#x27;);const path = require(&#x27;path&#x27;);const htmlmin = require(&#x27;gulp-htmlmin&#x27;);// 使用gulp.task()建立任务, 任务名称是htmlmingulp.task(&#x27;htmlmin&#x27;, async () =&gt; &#123;	gulp.src(&#x27;./src/*.html&#x27;) // 获取src下面的所有htm使用通配符*    // 压缩html文件中的代码    .pipe(htmlmin(&#123;collapseWhitespace: true&#125;))    .pipe(gulp.dest(&#x27;dist&#x27;))&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="抽取公共文件包含-gulp-file-include"><a href="#抽取公共文件包含-gulp-file-include" class="headerlink" title="抽取公共文件包含 gulp-file-include"></a>抽取公共文件包含 gulp-file-include</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fileinclude  = require(&#x27;gulp-file-include&#x27;);gulp.task(&#x27;htmlmin&#x27;, async () =&gt; &#123;	gulp.src(&#x27;./src/*.html&#x27;) // 获取src下面的所有htm使用通配符*    // 抽取公共代码    .pipe(fileinclude())    // 压缩html文件中的代码    .pipe(htmlmin(&#123;collapseWhitespace: true&#125;))    .pipe(gulp.dest(&#x27;dist&#x27;))&#125;)</span><br></pre></td></tr></table></figure>



<p>在common 文件中建立common文件夹， 然后抽取了公共代码</p>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528012917550.png" alt="image-20210528012917550"></p>
<p>最后在文件中通过@@include(‘公共代码文件路径’) 把公共文件引回来；</p>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528013137440.png" alt="image-20210528013137440"></p>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210528013152023.png" alt="image-20210528013152023"></p>
<p>最后执行 htmlmin  任务 命令行中输入 gulp htmlmin</p>
<h3 id="css代码less转cass语法转化-css代码压缩"><a href="#css代码less转cass语法转化-css代码压缩" class="headerlink" title="css代码less转cass语法转化 css代码压缩"></a>css代码less转cass语法转化 css代码压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  还是要先进行下载 npm install gulp-less // npm install gulp-cssoconst less = require(&#x27;gulp-less&#x27;);const csso = require(&#x27;gulp-csso&#x27;)// css 任务： // 1. less 语法转化// 2. css代码压缩gulp.task(&#x27;cssmin&#x27;, async () =&gt; &#123;    // 获取src/css下面的所有.less 和 所有的css文件 注意这里是数组的方式包含了2种文件    gulp.src([&#x27;./src/css/*.less&#x27;, &#x27;./src/css/*.css&#x27;])    .pipe(less()) // 先转化成css文件    .pipe(csso()) // 然后用gulp-csso 插件进行压缩css代码    .pipe(gulp.dest(&#x27;dist/css&#x27;))&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="es6-代码转化-js-代码压缩"><a href="#es6-代码转化-js-代码压缩" class="headerlink" title="es6 代码转化  js 代码压缩"></a>es6 代码转化  js 代码压缩</h2><ol>
<li><p>est代码转化首先要先用到 gulp-babel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Babel 7$ npm install --save-dev gulp-babel @babel/core @babel/preset-env# Babel 6$ npm install --save-dev gulp-babel@7 babel-core babel-preset-env</span><br></pre></td></tr></table></figure>
</li>
<li><p>js 代码压缩用到 gulp-uglify   npm install gulp-uglify</p>
</li>
<li><p>实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&#x27;gulp-babel&#x27;);const uglify = require(&#x27;gulp-uglify&#x27;);gulp.task(&#x27;jsmin&#x27;, async () =&gt; &#123;    gulp.src(&#x27;./src/js/*.js&#x27;)    .pipe(babel(&#123;        // 它可以判断当前代码的运行环境，将代码转化为当前运行环境所支持的代码        presets: [&#x27;@babel/preset-env&#x27;]    &#125;))    .pipe(uglify()) // 压缩js代码    .pipe(gulp.dest(&#x27;dist/js&#x27;))&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="将项目资源的文件夹复制到-打包后的文件夹中"><a href="#将项目资源的文件夹复制到-打包后的文件夹中" class="headerlink" title="将项目资源的文件夹复制到 打包后的文件夹中"></a>将项目资源的文件夹复制到 打包后的文件夹中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 复制静态资源 如image 文件夹gulp.task(&#x27;copy&#x27;, () =&gt; &#123;    // 复制image文件夹下的东西    gulp.src(&#x27;./src/images/*&#x27;)    .pipe(gulp.dest(&#x27;dist/images&#x27;))    // 复制lib文件夹下的东西    gulp.src(&#x27;./src/lib/*&#x27;)    .pipe(gulp.dest(&#x27;dist/lib&#x27;))&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="我们创建一个任务-去执行上面所有的任务-第二个参数是个数组"><a href="#我们创建一个任务-去执行上面所有的任务-第二个参数是个数组" class="headerlink" title="我们创建一个任务 去执行上面所有的任务  *** 第二个参数是个数组**"></a>我们创建一个任务 去执行上面所有的任务  *** 第二个参数是个数组**</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 建立构建任务 第二个参数是一个数组表示 要执行任务的集合gulp.task(&#x27;deafult&#x27;, [&#x27;htmlmin&#x27;, &#x27;cssmin&#x27;, &#x27;jsmin&#x27;, &#x27;copy&#x27;])</span><br></pre></td></tr></table></figure>

<p>*** 踩坑: 直接执行报错** </p>
<hr>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210529232332631.png" alt="image-20210529232332631"></p>
<p> 这个gulp -v 查看版本</p>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210529232144682.png" alt="image-20210529232144682"></p>
<p>如果是4.0 版本的 </p>
<p>第二个参数：即要执行的所有任务名称必须写成 gulp.series() 的参数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 建立构建任务 第二个参数是一个数组表示 要执行任务的集合gulp.task(&#x27;default&#x27;, gulp.series(&#x27;htmlmin&#x27;, &#x27;cssmin&#x27;, &#x27;jsmin&#x27;, &#x27;copy&#x27;))</span><br></pre></td></tr></table></figure>



<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>项目描述文件，记录的当前项目信息， 例如项目名称。 版本。作者， github地址。 当前依赖了哪些第三方模块等。 可使用 npm init -y命令生产</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;name&quot;: &quot;description&quot;, // 名称  &quot;version&quot;: &quot;1.0.0&quot;, // 版本  &quot;description&quot;: &quot;&quot;, // 版本  &quot;main&quot;: &quot;index.js&quot;, // 入口文件  &quot;scripts&quot;: &#123; // 命令的别名，用别名代替较长的命令    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [], // 关键词  &quot;author&quot;: &quot;&quot;, // 作者  &quot;license&quot;: &quot;ISC&quot;,  // isc 开业协议  &quot;dependencies&quot;: &#123; // 项目依赖，（本地或者线上都需要的依赖）    &quot;formidable&quot;: &quot;^1.2.2&quot;,    &quot;mime&quot;: &quot;^2.5.2&quot;  &#125;，  &quot;devDependencies&quot;: &#123; // 开发依赖（本地依赖） npm i --save-dev 进行下载  	&quot;gulp&quot;: &quot;^4.0.2&quot;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>npm install –production 安装生产依赖（dependencies）</strong></p>
<p><strong>下面的依赖</strong> </p>
<h2 id="scripts-命令的别名"><a href="#scripts-命令的别名" class="headerlink" title="scripts 命令的别名"></a>scripts 命令的别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123; // 命令    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;buld&quot;: &quot;nodemon app.js&quot; // npm run build 相当于=&gt; nodemon app.js   &#125;,</span><br></pre></td></tr></table></figure>



<h1 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h1><p>记录了模块与模块之前的依赖关系， 以及模块的版本， 以及包的下载地址；</p>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>超文本传输协议， 规定了 如何从网站传输超文本 到浏览页， 是客户端（用户）和服务器端（网站）请求和应对的标准</p>
<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><p>在HTTP 和响应过程中传递数据块 叫作报文， 包括要传送的数据和一些附加信息， 并且要遵守规定的格式。</p>
<p> 报文分为请求报文和响应报文 </p>
<p>请求报文：</p>
<table>
<thead>
<tr>
<th>请求方式（method）</th>
<th>post， get</th>
</tr>
</thead>
<tbody><tr>
<td>请求地址（url）</td>
<td><a target="_blank" rel="noopener" href="http://www.baidu.con/">www.baidu.con</a></td>
</tr>
<tr>
<td>请求报文（headers）</td>
<td></td>
</tr>
</tbody></table>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210530161502955.png" alt="image-20210530161502955"></p>
<p>响应报文：</p>
<table>
<thead>
<tr>
<th>内容类型</th>
<th align="left">text&#x2F;html</th>
</tr>
</thead>
<tbody><tr>
<td>内容长度</td>
<td align="left">20</td>
</tr>
<tr>
<td>HTTP状态码</td>
<td align="left">200 请求成功  404 请求资源没有找到 500 服务端错误  400 客户端有语法错误</td>
</tr>
<tr>
<td>res.writeHead(状态码， 响应报文)</td>
<td align="left">设置响应报文</td>
</tr>
<tr>
<td>内容类型（content-type）</td>
<td align="left">text&#x2F;plain、text&#x2F;html、 text&#x2F;css、application&#x2F;javascripte、 image&#x2F;jpeg、 application&#x2F;json</td>
</tr>
<tr>
<td>content-type</td>
<td align="left">text&#x2F;html;charset&#x3D;utf8 (表明以utf8编码响应字符)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;); // 获取服务器模块const app = http.createServer(); // app就是网络服务器对象// 当客服端有请求的时候app.on(&#x27;request&#x27; , (req, res) =&gt; &#123;        // 设置响应内容和字符串编码    // 响应 res    res.writeHead(状态码, 内容类型)；    res.writeHead(400, &#123;    	&#x27;content-type&#x27;: &#x27;text/html;charset=utf8&#x27;    &#125;)            // 请求方式    if(req.method === &#x27;POST&#x27;) &#123;  // req.method 请求方式        res.end(&#x27;我提交post&#x27;)    &#125; else if (req.method === &#x27;GET&#x27;) &#123;        res.end(&#x27;end&#x27;);    &#125;            // req.url 是请求地址    if (req.url === &#x27;/index&#x27; || req.url === &#x27;/&#x27;) &#123;        res.end(&#x27;welcome homepage&#x27;)    &#125; else if(req.url === &#x27;/list&#x27;) &#123;        res.end(&#x27;welocome list&#x27;)    &#125; else &#123;        res.end(&#x27;not found&#x27;)    &#125;                // req.headers 获取请求报文    &#123; host: &#x27;localhost:3000&#x27;,  connection: &#x27;keep-alive&#x27;,  &#x27;cache-control&#x27;: &#x27;max-age=0&#x27;,  &#x27;upgrade-insecure-requests&#x27;: &#x27;1&#x27;,  &#x27;user-agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36&#x27;,  accept:  &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&#x27;,  &#x27;accept-encoding&#x27;: &#x27;gzip, deflate, br&#x27;,  &#x27;accept-language&#x27;: &#x27;zh-CN,zh;q=0.9&#x27; &#125;                                // 服务器发送    // res.end(&#x27;&lt;h1&gt;http&lt;/h1&gt;&#x27;);&#125;)app.listen(3000);</span><br></pre></td></tr></table></figure>

<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>客户端向服务器端发送请求时， 有时需要向服务端携带一些数据（如用户的信息等）， 这都是通过请求参数的形式传递到服务器端；</p>
<p><img src="C:\Users\Mloong\AppData\Roaming\Typora\typora-user-images\image-20210530163631713.png" alt="image-20210530163631713"></p>
<h3 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h3><p>请求参数被放置在浏览器地址中： 如 <a target="_blank" rel="noopener" href="http://localhost:3000/?name=zhangsan&age=20%EF%BC%9B">http://localhost:3000/?name=zhangsan&amp;age=20；</a> 传递了 name： zhangsan   和 age： 20</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.url = http://localhost:3000/index?name=zhangsan&amp;age=20 const url = require(&#x27;url&#x27;);url.parse(req.url)返回的是一个对象&#123; // url 系统模块用来处理url地址，这里处理的是请求地址 返回对象  protocol: null,  slashes: null,  auth: null,  host: null,  port: null,  hostname: null,  hash: null,  search: &#x27;?name=zhangsan&amp;age=20&#x27;,  query: &#x27;name=zhangsan&amp;age=20&#x27;,  pathname: &#x27;/index&#x27;,  path: &#x27;/index?name=zhangsan&amp;age=20&#x27;,  href: &#x27;/index?name=zhangsan&amp;age=20&#x27;  &#125; </span><br></pre></td></tr></table></figure>

<p><strong>我们只想拿到 name： zhangsan   和 age： 20 这种参数以键值对的形式 用 url.parse(req.url, true), 第二个参数传true 就可以了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&#x27;url&#x27;);url.parse(req.url, true)第二个参数传入true，返回的是一个对象注意 这个对象的 query值  已经是以键值对&#123;  protocol: null,  slashes: null,  auth: null,  host: null,  port: null,  hostname: null,  hash: null,  search: &#x27;?name=zhangsan&amp;age=20&#x27;,  query: [Object: null prototype] &#123; name: &#x27;zhangsan&#x27;, age: &#x27;20&#x27; &#125;,  pathname: &#x27;/index&#x27;,  path: &#x27;/index?name=zhangsan&amp;age=20&#x27;,  href: &#x27;/index?name=zhangsan&amp;age=20&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST-请求参数；"><a href="#POST-请求参数；" class="headerlink" title="POST 请求参数；"></a>POST 请求参数；</h3><p>由于post参数不是在url中， 我们不能用req.url 获取；</p>
<p>*** POST 参数是通过2个事件的方式接受的data事件和end 事件**</p>
<p>data 事件： 当请求参数传递的时候触发data事件，（有可能是100M的数据，这里每次都是触发data事件）</p>
<p>end事件：当参数传递完成时候触发end事件</p>
<p>***post参数处理使用 queryString的parse方法，不同get处理，不能使用url 模块， **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;); // 获取服务器模块const app = http.createServer(); // app就是网络服务器对象const queryString = require(&quot;querystring&quot;); // 处理post请求参数模块// 当客服端有请求的时候app.on(&#x27;request&#x27; , (req, res) =&gt; &#123;    let postParams = &#x27;&#x27;;    req.on(&#x27;data&#x27;, params =&gt; &#123;        postParams +=  params    &#125;)    req.on(&#x27;end&#x27;, () =&gt; &#123;    	// 使用queryString.parse() 方法处理参数        let data = queryString.parse(postParams);        console.log(data)        // data是一个对象 &#123;&#125;    &#125;)    res.end(&#x27;ok&#x27;)&#125;)app.listen(3000);</span><br></pre></td></tr></table></figure>



<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在网站服务中 我们访问 <a target="_blank" rel="noopener" href="http://localhost:3000/index">http://localhost:3000/index</a> 是首页 </p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:3000/login">http://localhost:3000/login</a> 是登录页 这个是通过路由做到的</p>
<p>路由 是指客户端请求地址与服务器程序代码的对应关系。 简单的说，就是根据不同请求 去响应不同的内容；</p>
<p>路由当中是一堆判断代码， 根据不同的请求路径 去判断 应该是什么响应内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;); // 获取服务器模块const url = require(&#x27;url&#x27;);const app = http.createServer(); // app就是网络服务器对象// 当客服端有请求的时候app.on(&#x27;request&#x27; , (req, res) =&gt; &#123;    res.writeHead(200, &#123;        &#x27;content-type&#x27;: &#x27;text/html;charset=utf8&#x27;    &#125;)      let &#123;pathname&#125; = url.parse(req.url, true)     if (pathname === &#x27;/index&#x27; || pathname === &#x27;/&#x27;) &#123;        res.end(&#x27;登录页&#x27;)    &#125; else if(pathname === &#x27;/list&#x27;) &#123;        res.end(&#x27;列表页&#x27;)    &#125; else &#123;        res.end(&#x27;没有找到对应内容&#x27;)    &#125;&#125;)app.listen(3000);</span><br></pre></td></tr></table></figure>



<h1 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h1><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>客户端向服务器发送一些请求， 服务器不需要做任何的处理， 可以直接响应的文件。 如 js、 css 、 html 、 image 文件</p>
<p><a target="_blank" rel="noopener" href="https://www.itcast.cn/images/logo.png">https://www.itcast.cn/images/logo.png</a></p>
<p>原理：</p>
<ol>
<li>拿到用户的请求路径 default.html； </li>
<li>去读取磁盘上的物理路径上的文件，然后把这个文件返回给客户端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);const app = http.createServer();const url = require(&#x27;url&#x27;);const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);app.on(&#x27;request&#x27;, (req, res) =&gt; &#123;   // 1.    let pathname = url.parse(req.url).pathname; // 这里直接获取请求的 不包括参数    let realpath = path.join(__dirname + pathname); // 这里用path将 当前的路径 和 请求路径进行拼接    // 2. 接下来直接调用fs， 进行读取路径下的文件内容； 然后返回    fs.readFile(realpath, (err, result) =&gt; &#123;        if (err) &#123;            res.writeHead(200, &#123;                &#x27;content-type&#x27;: &#x27;text/html;charset=utf8&#x27;            &#125;)            res.end(&#x27;文件读取失败&#x27;);            return;        &#125;        res.end(result) // 返回读取的结果    &#125;)&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mime-第三方插件；-可以区分出当前请求的文件类型；-如当前请求的是-html-文件还是-css文件-，-然后设置正确的-响应content-type-从而展示正确的文件"><a href="#mime-第三方插件；-可以区分出当前请求的文件类型；-如当前请求的是-html-文件还是-css文件-，-然后设置正确的-响应content-type-从而展示正确的文件" class="headerlink" title="mime 第三方插件； 可以区分出当前请求的文件类型； 如当前请求的是 html 文件还是 css文件 ， 然后设置正确的 响应content-type 从而展示正确的文件"></a>mime 第三方插件； 可以区分出当前请求的文件类型； 如当前请求的是 html 文件还是 css文件 ， 然后设置正确的 响应content-type 从而展示正确的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mime = require(&#x27;mime&#x27;);1. 拿到请求的路径let realpath = path.join(__dirname + pathname); // 这里用path将 当前的路径 和 请求路径进行拼接let type = mime.getType(realpath); // 这里拿到本次正确的文件类型2. 去该路径下去读响应的文件fs.readFile(realpath, (err, result) =&gt; &#123;        if (err) &#123;            res.writeHead(200, &#123;                &#x27;content-type&#x27;: &#x27;text/html;charset=utf8&#x27;            &#125;)            res.end(&#x27;文件读取失败&#x27;);            return;        &#125;        res.writeHead(200, &#123;            &#x27;content-type&#x27;: type // 设置响应内容        &#125;)        res.end(result) // 返回读取的结果    &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="动态资源："><a href="#动态资源：" class="headerlink" title="动态资源："></a>动态资源：</h2><p>相同的请求地址，返回不同的响应，这种资源就是动态资源</p>
<p><a target="_blank" rel="noopener" href="http://yun.itheima.com/map?id=2">http://yun.itheima.com/map?id=2</a></p>
<p><a target="_blank" rel="noopener" href="http://yun.itheima.com/map?id=1">http://yun.itheima.com/map?id=1</a></p>
<h1 id="promise-异步-编程解决方案，-解决回调地狱问题"><a href="#promise-异步-编程解决方案，-解决回调地狱问题" class="headerlink" title="promise 异步 编程解决方案， 解决回调地狱问题"></a>promise 异步 编程解决方案， 解决回调地狱问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;	setTimeout(() =&gt; &#123;		resolve(&#123;name: &#x27;zhangsan&#x27;&#125;)	&#125;, 1000)&#125;)promise.then(res =&gt; &#123;	console.log(res) // &#123;name: &#x27;zhangsan&#x27;&#125;&#125;)// 读取文件案例const fs = require(&#x27;fs&#x27;);let promise = new Promise((resolve, reject) =&gt; &#123;	fs.readFile(&#x27;./a.js&#x27;, (err, res) =&gt; &#123;		if(err) &#123;			reject(err)		&#125; else &#123;			resolve(res)		&#125;	&#125;)&#125;)promise.then((res) =&gt; &#123;	console.log(res) // 文件内容&#125;).catch((err) =&gt; &#123;	console.log(err);&#125;)async function fn() &#123;	throw &#x27;发生了错误&#x27;&#125;fn().then() &#123;&#125;.catch( e =&gt; &#123;	console.log(e)&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1><p>普通函数定义前加async 普通函数就变成了异步函数</p>
<p>异步函数都是返回的promise 对象， return 的值就是 resolve 的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function fn() &#123;	return 1&#125;fn().then(res) &#123;// fn 执行结果就是一个promise 对象	console.log(res) // res 就是 fn函数中 return 的值&#125;.catch( e =&gt; &#123;	console.log(e)&#125;)</span><br></pre></td></tr></table></figure>

<p>await 后面要跟着一个 promise 对象 await 可以暂定异步函数向下执行， 后续的代码等 await 有了结果才执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function fn() &#123;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br><span class="line">async function fun() &#123;</span><br><span class="line">	let f1 = await fn() // fn是异步函数，它执行就是返回一个promise对象</span><br><span class="line">	let f2 = await new Promise((res, rej) =&gt; &#123;</span><br><span class="line">		res(1)</span><br><span class="line">	&#125;) // 这里 new Promise 创建的也是一个promise 对象</span><br><span class="line">	let f = f1 + f2</span><br><span class="line">	console.log(f)</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/node-js/" rel="tag"># node.js</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/05/28/css/" rel="prev" title="css">
      <i class="fa fa-chevron-left"></i> css
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/28/js/" rel="next" title="js">
      js <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%9A%84-node-%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">三种主流的 node  程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#module-exports-%E5%92%8C-exports"><span class="nav-number">1.1.</span> <span class="nav-text">module.exports 和 exports</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.</span> <span class="nav-text">模块查找原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#require%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%E6%89%80%E4%BB%A5%E4%B8%80%E8%88%AC%E5%86%99%E5%9C%A8%E6%96%87%E4%BB%B6%E9%A1%B6%E9%83%A8"><span class="nav-number">1.3.</span> <span class="nav-text">require方法是同步方法 所以一般写在文件顶部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node%E4%BC%9A%E6%8A%8A%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%BC%93%E5%AD%98%E8%B5%B7%E6%9D%A5%E3%80%82-%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E4%BA%86%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AArequire%E4%BC%9A%E6%8A%8A%E6%A8%A1%E5%9D%97%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C-%E8%BF%99%E6%A0%B7%E7%AC%AC%E4%BA%8C%E4%B8%AArequire%E5%B0%B1%E4%B8%8D%E5%9C%A8%E5%8E%BB%E8%AE%BF%E9%97%AE%E5%92%8C%E8%AE%A1%E7%AE%97%E6%BA%90%E6%96%87%E4%BB%B6%E4%BA%86%E3%80%82"><span class="nav-number">1.4.</span> <span class="nav-text">node会把模块作为对象缓存起来。 如果两个文件引入了相同的模块，第一个require会把模块返回的数据存在内存中， 这样第二个require就不在去访问和计算源文件了。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="nav-number">1.5.</span> <span class="nav-text">异步编程技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B0%84%E5%99%A8-%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E3%80%81%E8%83%BD%E5%A4%9F%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B0%84%E5%8F%8A%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E7%9A%84%E7%B1%BB%EF%BC%88EventEmitter%EF%BC%9B"><span class="nav-number">1.6.</span> <span class="nav-text">事件发射器  一个可以继承、能够添加事件发射及处理能力的类（EventEmitter；)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fs-%E6%96%87%E4%BB%B6%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="nav-number">2.</span> <span class="nav-text">fs 文件的系统模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#path-%E6%A8%A1%E5%9D%97"><span class="nav-number">3.</span> <span class="nav-text">path 模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-%E6%A8%A1%E5%9D%97-%E5%8E%BBHTTP%E5%8D%8F%E8%AE%AE%E6%9F%A5%E7%9C%8B"><span class="nav-number">4.</span> <span class="nav-text">http 模块 去HTTP协议查看</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#url-%E6%A8%A1%E5%9D%97-%E5%A4%84%E7%90%86url%E5%9C%B0%E5%9D%80-%E5%8E%BB%E6%8A%A5%E6%96%87get%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%9F%A5%E7%9C%8B"><span class="nav-number">5.</span> <span class="nav-text">url 模块 处理url地址 去报文get请求参数查看</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nodemon-%E6%A8%A1%E5%9D%97"><span class="nav-number">6.</span> <span class="nav-text">nodemon 模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nrm"><span class="nav-number">7.</span> <span class="nav-text">nrm</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gulp"><span class="nav-number">8.</span> <span class="nav-text">gulp</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gulp-%E5%9F%BA%E4%BA%8Enode-%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="nav-number">8.1.</span> <span class="nav-text">gulp 基于node 平台开发的前端构建工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gulp-%E4%BD%BF%E7%94%A8"><span class="nav-number">8.1.1.</span> <span class="nav-text">gulp 使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gulp%E6%8F%92%E4%BB%B6%E5%8E%BB%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%88%E5%B9%B6%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD"><span class="nav-number">8.2.</span> <span class="nav-text">gulp插件去实现文件的合并压缩功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9html%E6%96%87%E4%BB%B6-gulp-htmlmin"><span class="nav-number">8.2.1.</span> <span class="nav-text">压缩html文件   gulp-htmlmin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E5%8F%96%E5%85%AC%E5%85%B1%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-gulp-file-include"><span class="nav-number">8.2.2.</span> <span class="nav-text">抽取公共文件包含 gulp-file-include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#css%E4%BB%A3%E7%A0%81less%E8%BD%ACcass%E8%AF%AD%E6%B3%95%E8%BD%AC%E5%8C%96-css%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9"><span class="nav-number">8.2.3.</span> <span class="nav-text">css代码less转cass语法转化 css代码压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6-%E4%BB%A3%E7%A0%81%E8%BD%AC%E5%8C%96-js-%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9"><span class="nav-number">8.3.</span> <span class="nav-text">es6 代码转化  js 代码压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6%E5%88%B0-%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD"><span class="nav-number">8.4.</span> <span class="nav-text">将项目资源的文件夹复制到 打包后的文件夹中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1-%E5%8E%BB%E6%89%A7%E8%A1%8C%E4%B8%8A%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%BB%E5%8A%A1-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">8.5.</span> <span class="nav-text">我们创建一个任务 去执行上面所有的任务  *** 第二个参数是个数组**</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#package-json"><span class="nav-number">9.</span> <span class="nav-text">package.json</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scripts-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">9.1.</span> <span class="nav-text">scripts 命令的别名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#package-lock-json"><span class="nav-number">10.</span> <span class="nav-text">package-lock.json</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">11.</span> <span class="nav-text">HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87"><span class="nav-number">11.1.</span> <span class="nav-text">报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">11.2.</span> <span class="nav-text">请求参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">11.2.1.</span> <span class="nav-text">GET请求参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%EF%BC%9B"><span class="nav-number">11.2.2.</span> <span class="nav-text">POST 请求参数；</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1"><span class="nav-number">12.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">13.</span> <span class="nav-text">静态资源的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">13.1.</span> <span class="nav-text">静态资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mime-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%EF%BC%9B-%E5%8F%AF%E4%BB%A5%E5%8C%BA%E5%88%86%E5%87%BA%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9B-%E5%A6%82%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%AF-html-%E6%96%87%E4%BB%B6%E8%BF%98%E6%98%AF-css%E6%96%87%E4%BB%B6-%EF%BC%8C-%E7%84%B6%E5%90%8E%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84-%E5%93%8D%E5%BA%94content-type-%E4%BB%8E%E8%80%8C%E5%B1%95%E7%A4%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.1.</span> <span class="nav-text">mime 第三方插件； 可以区分出当前请求的文件类型； 如当前请求的是 html 文件还是 css文件 ， 然后设置正确的 响应content-type 从而展示正确的文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%9A"><span class="nav-number">13.2.</span> <span class="nav-text">动态资源：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#promise-%E5%BC%82%E6%AD%A5-%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C-%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">promise 异步 编程解决方案， 解决回调地狱问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-await"><span class="nav-number">15.</span> <span class="nav-text">async await</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaowang"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">zhaowang</p>
  <div class="site-description" itemprop="description">病了就要吃药</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/izhaowang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;izhaowang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:izhwang@126.com" title="E-Mail → mailto:izhwang@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhaowang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
