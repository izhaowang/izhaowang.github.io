<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在url地址栏输入 地址访问 经历 ：    1. 浏览器把输入的网址，解析为ip；    1.1 首先查找浏览器缓存，如果有缓存，那么直接返回ip，否则进行下一步    1.2 查看系统缓存， 浏览器进行系统调用（window 的gethostname ），查找host文件， 直接返回ip； 没有下一步    1.3 查找路由器缓存， 借助网络，查找isp服务商缓存的DNS服务器，找到返回ip，">
<meta property="og:type" content="article">
<meta property="og:title" content="js">
<meta property="og:url" content="http://example.com/2022/03/28/js/index.html">
<meta property="og:site_name" content="旺旺小小酥">
<meta property="og:description" content="在url地址栏输入 地址访问 经历 ：    1. 浏览器把输入的网址，解析为ip；    1.1 首先查找浏览器缓存，如果有缓存，那么直接返回ip，否则进行下一步    1.2 查看系统缓存， 浏览器进行系统调用（window 的gethostname ），查找host文件， 直接返回ip； 没有下一步    1.3 查找路由器缓存， 借助网络，查找isp服务商缓存的DNS服务器，找到返回ip，">
<meta property="og:locale">
<meta property="article:published_time" content="2022-03-28T06:21:27.000Z">
<meta property="article:modified_time" content="2023-03-08T04:50:05.939Z">
<meta property="article:author" content="zhaowang">
<meta property="article:tag" content="js">
<meta property="article:tag" content="es5">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/03/28/js/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>js | 旺旺小小酥</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">旺旺小小酥</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">路虽远，行则至</p>
      <a>
        <img class="custom-logo-image" src="/uploads/custom-logo.jpg" alt="旺旺小小酥">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/28/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="zhaowang">
      <meta itemprop="description" content="病了就要吃药">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旺旺小小酥">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          js
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-28 14:21:27" itemprop="dateCreated datePublished" datetime="2022-03-28T14:21:27+08:00">2022-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 12:50:05" itemprop="dateModified" datetime="2023-03-08T12:50:05+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AFjs/" itemprop="url" rel="index"><span itemprop="name">前端js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在url地址栏输入 地址访问 经历 ：<br>    1. 浏览器把输入的网址，解析为ip；<br>    1.1 首先查找浏览器缓存，如果有缓存，那么直接返回ip，否则进行下一步<br>    1.2 查看系统缓存， 浏览器进行系统调用（window 的gethostname ），查找host文件， 直接返回ip； 没有下一步<br>    1.3 查找路由器缓存， 借助网络，查找isp服务商缓存的DNS服务器，找到返回ip，没有下一步<br>    （递归查询， 迭代查询）<br>    2. 浏览器与目标建立tcp连接：<br>    2.1 主机浏览器拿到目标服务器的ip地址后， 与服务器建立tcp连接<br>    2.2 tcp3次握手建立连接：<br>            第一次：浏览器所在的主机（本机）向目标服务器发出请求报文（SYN标志为1）<br>            第二次：目标服务器接受报文后，同意建立连接，向客户端发出确认报文（SYN, ACK 标志均为1）<br>            第三次：客户端确认收到报文后，再次向服务器发出报文，确认已收到确认报文（客户端与服务器TCP连接确认完成，开始通信）<br>   3. 浏览器通过http协议发送请求<br>    浏览器发送一个HTTP-GET 方法报文请求。 请求中包含URL， KeepAlive 长连接，还有 User-Agent<br>    用户浏览器操作系统信息，编码等。 其中Accep-Encoding （压缩gzip）和 Cookies（用户首次访问，会提示<br>    服务器建立用户缓存信息， 不是首次访问利用Cookies对应的键值对，找到相应的缓存，缓存中存放着用户名，密码和一些用户设置项）项，<br>    4. 某些服务会做永久重定向响应：<br>    大型网站 一般不会直接返回请求页面，（状态码不是200， 而是301,302 以3开头的重定向码，浏览器获取了重定向响应<br>    后，在响应报文中获取到location项找到重定向地址，重新第一步访问即可）<br>        重定向作用： 主要是2点 : 1.为了负载均衡（减少服务器压力）；  2.重定向可以将多个域名的访问，集中多一个站点<br>            如：baidu.com 和 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 搜索引擎认为是两个网站，永久重定向会将两个地址关联起来<br>            ，搜索引擎任务是同一个网站，提高排名<br>    5. 浏览器跟踪重定向地址： 浏览器拿到重定向地址后，重新发送一个http请求<br>    6. 服务器处理请求： 服务器收到获取请求，处理并返回一个响应报文。<br>    7. 根据报文的Content-type  响应文件呈现形式<br>    8. 释放tcp连接:<br>    8.1 浏览器所在的主机向服务器发出连接释放报文，然后停止发送数据；<br>    8.2 服务器接收到报文后确认报文，然后将服务器上未传送完的数据发送完；<br>    8.3 服务器数据传输完毕后，向客户端发送连接释放报文；<br>    8.4 客户端接受到报文后，发出确认，然后释放tcp连接<br>    9. 浏览器根据对应的渲染机制 渲染html</p>
<ol>
<li><p>浏览器渲染原理<br> 首先下载静态资源<br> 解析html时，发现其中有其他外部资源链接 如css、js、图片等， 会立即开启其他线程下载。<br> 当外部资源下载js时， html解析会停下来。 等js下载 执行结束后才继续 解析HTML<br> 解析html&#x3D;》构建DOM树<br> 解析CSS &#x3D;&gt; 构建CSSOM树<br> 利用DOM 和 CSSOM树 构建 Render树<br> 进行布局 layout<br> 进行绘制	painting 到屏幕上</p>
<p> 当某个部分发生改变，影响到布局， 进行重排 reflow<br> 当某个元素背景、边框颜色等发生改变， 进行重回 repaint</p>
</li>
</ol>
<h1 id="script-标签的defer属性和async属性"><a href="#script-标签的defer属性和async属性" class="headerlink" title="script 标签的defer属性和async属性"></a>script 标签的defer属性和async属性</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。一旦加载完成后会执行js；</span><br><span class="line">有可能在 DOMContentLoaded之前执行，也有可能在DOMContentLoaded之后执行。但是一定在load之前执行；</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</span><br></pre></td></tr></table></figure>
<h2 id="defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序"><a href="#defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序" class="headerlink" title="defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序"></a>defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序</h2><h1 id="DOMContentLoaded-，-onload"><a href="#DOMContentLoaded-，-onload" class="headerlink" title="DOMContentLoaded ， onload"></a>DOMContentLoaded ， onload</h1><p>1、当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>
<p>2、当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>
<p>window.onload ：页面全部加载完成包括图片<br>DOMContentLoad：dom渲染完成即可，此时图片视频可能还没有加载完<br>2. 变量<br>    let 在同一个作用域中，不能重复声明同一个变量。 for 循环 判断条件和 代码块中 是两个作用域<br>    let 声明的变量不能 变量提升到 顶层。   &#x3D;》 导致存在暂时性 死区。</p>
<pre><code>const 同let 一样。 const 声明的变量 内存地址不能改变
</code></pre>
<ol start="3">
<li><p>结构赋值<br> let {foo: {bar}} &#x3D; {baz: ‘baz’}; &#x2F;&#x2F; 会报错<br> 原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 </p>
<ol>
<li>数组的 结构赋值</li>
<li>对象的结构赋值</li>
<li>let arr &#x3D; [1, 2, 3] ；<br> let {0：a, [arr.length-1]: b, 1:c} &#x3D; arr &#x2F;&#x2F; 此时将数组转化为 伪数组对象</li>
<li>字符串的结构赋值 &#x3D;》 转化为 伪数组对象 const [a,b] &#x3D; ‘hi’  let {length: len} &#x3D; ‘hello’</li>
<li>数值和布尔值的结构赋值 数值和布尔值 都有 封装的toString 属性， 因此<br> let {toString：s} &#x3D; 123；<br> let {toString：s} &#x3D; true；</li>
<li>let {proxy： x} &#x3D; undefined  报错 let {prop： x} &#x3D; null<br> null 和 undefined 没有包装对象。 对他们进行结构都会报错</li>
<li>函数参数的解构赋值</li>
</ol>
</li>
<li><p>字符串：</p>
<ol>
<li>“hellow”.charAt(0)， 返回0处的 值  &#x3D;》 h</li>
<li>‘hellow’.charCodeAt(0), 返回0处值 的 unicode 编码 是一个数字<br> String.fromCharCode(数字) &#x3D;》 将 unicode 编码数字 转化为对应的 字符串</li>
<li>字符串是已UTF-16 格式储存， 每个字符固定是 2个字节。 对于 4个字节储存的 字符， js认为是2个字符<br>ES3 提供了 codePointAt方法，能够正确处理4个字节储存的字符。 返回一个字符的 码点 数字<br>   “级”.codePointAt(0) &#x2F;&#x2F; 32423<br>  Strgin.fromCodePoint(32423) &#x3D;&gt; ‘级’</li>
</ol>
</li>
<li><p>函数<br> length 属性 含义： 该函数预期传入的参数个数， 某个参数指定默认值后， 预期参数个数就不包括这个参数<br>     rest 参数也不计入length属性； 因为rest 意义就是 不知道会传入几个参数，统一代替的<br> (function (a &#x3D; 0, b, c) {}).length &#x2F;&#x2F; 0<br> (function (a, b &#x3D; 1, c) {}).length &#x2F;&#x2F; 1  如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。	</p>
<p> 默认参数，函数声明初始化时，参数会形成一个单独的作用域。  有且只有设置默认值时，才会出现 这个作用域</p>
</li>
</ol>
<p>arguments.callee 指向  是arguments 的一个属性指向正在运行的 函数<br>（function（） {}）.caller 是函数的一个 一个属性 指向正在运行的 函数 在window 下 调用 直接是null<br>6.箭头函数	<br>    如果箭头函数直接返回一个对象， 就必须在对象外面加上括号，否则会报错： let getTime &#x3D; time &#x3D;&gt; ({time: Date.now()});</p>
<p> Vue 通过建立一个虚拟DOM 来追踪自己如果要改变真实DOM<br>return createElement（’h1’, this.title）； &#x3D;》》 createElement 函数返回的就是一个{Vnode} 虚拟 节点 </p>
<p>Vue的生命周期</p>
<ol>
<li><p>beforeCreate 实例创建之前除非，不能访问data computed watch 的数据<br>2.created 实例创建后发生， 可以访问data中的数据， 当前不能与dom 进行交互</p>
</li>
<li><p>beforeMount 发生在挂载之前， 此时虚拟dom已经创建完成<br>4.mounted 在挂载完成后发生， 真实的dom挂载完成，数据完成双向绑定；可以访问dom节点，</p>
</li>
<li><p>beforeUpdate 发生在更新之前，响应式数据更新，但是虚拟dom还没有渲染，<br>6.updated 发生在更新完成之后，当前阶段组件dom已经更新完成<br>7.beforeDestory 发生在实例销毁之前，在当前阶段实例可以被使用， 我们可以清除计时器等<br>8.destoryed 发生在实例销毁之后， 这个时候组件被拆解，数据被卸载，监听被移除</p>
</li>
<li><p>实例创建之前，不能访问data 、 实例创建之后；可以访问到data数据； 不能与 dom 进行交互<br> 挂载之前， 此时虚拟dom已经创建完成；  挂载之后完成； 真实的dom完成挂咋； 数据完成双向绑定；可以访问dom节点<br>发生再更新之前， 响应式数据； 但是虚拟dom 没有渲染之前被触发；  发生再更新完成之后， 当前阶段组件dom已经更新完成<br>发生再实例销毁之前， 此时实例可以被调用  发生再实例销毁之后， 这个时候组件被拆解 数据被卸载， 监听被移除</p>
</li>
</ol>
<p>Vue.extend() 创建vue 的一个子类<br>nextTick 异步队列，主要是监听DOM 更新完成；<br>主要当前浏览器环节使用 promise mutationObserver setImmediate 或者 setTimout方法</p>
<p>Vue2.x 监听数组的变化： vue 会将数组的原型方法进行重写； 每次调用时，会监听到数组的更改，然后通知视图进行更新；<br> 如果是有引用类型，那么就对数组进行递归进行监听，</p>
<p>1.浮动 影响自身 和同级后面元素的位置<br>2.浮动会造成父级高度的塌陷；影响正常文档流布局； 所以需要清除浮动<br>    1.清除浮动的方法: 给父级 添加overflow hidden属性； 给浮动元素同级后面 添加一个div元素，设置clear:both<br>    ; 给父级设置伪类：after {display: block; content: ‘’; visibility:hidden;clear:both; height:0} 三种方法<br>3. </p>
<p>key值： vue为了尽可能降低dom操作，尽可能的复用已有的dom 而非重新渲染；key的作用是给节点一个唯一标识，<br>以便能够再操作dom时找到可以复用的节点；</p>
<p>keep-alive 的用法 缓存动态组件； vue2.0版本后， 内置组件已经封装了两个属性， include 表示缓存的组件； exclude表示不需要缓存<br>    可以是名字或者 </p>
<p>2.4 $attrs 和 $listeners 属性<br>inheritAttrs 默认是 true 继承所有父组件属性,除了props 的特定绑定;作为普通的html属性应用在 子组件的根元素;<br>如果inheritAttrs是false，但是class 属性会继承；</p>
<p>$listeners–属性，它是一个对象，里面包含了作用在这个组件上的所有监听器，你就可以配合 v-on&#x3D;”$listeners”<br>将所有的事件监听器指向这个组件的某个特定的子元素。</p>
<p>inheritAttrs 继承所有的属性 除了props； </p>
<p>模块化的前世今生<br>模块化就是将一个复杂的系统分解成多个独立的模块； 之前都是通过一系列的script 标签来维护 模块之前的关系；<br>但是一旦项目复杂。 这个方式 就会使我们的代码混乱不堪；<br>由于早期官方 并没有提供统一的解决方案，所以早期 关于模块化方案层出不穷。<br>IIFE ： 模块化的一大作用就是用来隔离作用域，避免变量冲突； 最早为了避免与全局变量污染， 智能使用闭包来实现模块化。<br>（function (window) {<br>    window.query &#x3D; {} ;<br>}）(window)<br>&#x2F;&#x2F; 虽然IIFE 有效解决了命名冲突的问题， 但是对于依赖管理， 还是束手无策。 因为浏览器时自上而下的执行脚本；为了维持脚本<br>间的依赖关系；就必须手动维护好script 标签 相对顺序<br>AMD： 一种模块化规范， 主要提供了异步加载功能；  需要使用RequireJS去实现模块化；  所有的依赖像必须提前声明好；<br>在导入模块的时候，也会先加载对应的依赖模块， 然后再执行后续代码，AMD可以并发加载所有的依赖模块；<br>define（’.&#x2F;index.js’, function(code) {<br>    &#x2F;&#x2F; code 时index.js 返回的内容	<br>return {<br>    }<br>}）<br>CMD：通由阿里玉伯提出；通AMD类型， CMD需要SeaJS 库来实现模块化；同AMD 一样； CMD也是为了解决 依赖管理问题；<br>define（function （require） {<br>    var path &#x3D; require.resolve(‘.&#x2F;cmdDefine’);<br>    alert(path)<br>）<br>  CMD 加载完某个依赖模块后并不执行，只是下载而已， 再所有依赖模块加载完成后进入主逻辑， 如果 require语句才执行<br>对应的模块， 用require.asynce（） 可以实现赖加载<br>CommonJS， 随着模块化深入； 需要一种标准的模块化方案； 此时commonJS 应运而生； node.js应用就是采用这个规范；<br>内置module对象 定义模块； require 函数来加载模块文件<br>var add &#x3D; funciton（a, b） {}<br>module.exports &#x3D; {<br>    add: add<br>}</p>
<p>&#x2F;&#x2F; 加载模块<br>var utils &#x3D; require（’.&#x2F;utils’）<br>console.log(utils.add(1,2)) &#x2F;&#x2F; 3<br>这种模块化方案特点就是：同步阻塞式加载，无法实现按需异步加载。如果时浏览器环境使用CommonJS 模块 需要Browserify<br>进行解析；</p>
<p>UMD： 上面CommonJs 合AMD 等模块化方案都是针对特定的平台； 如果想要实现 跨平台的模块化， 可以兼容 AMD 合 commonJs<br>等模块化语法</p>
<p>ES6 modules<br>export<br>import</p>
<p>CommonJS 合 ES6 模块的两大差异</p>
<ol>
<li>CommonJS 输出的是一个值的拷贝； Es6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载， es6模块时编译时输出接口</li>
</ol>
<p>第二个差异是因为 CommonJS 加载的是一个对象（module.exports 属性），<br>该对象只有在脚本运行完才会生成。 </p>
<p>而es6模块不是对象； 它的对外接口只是一种静态定义’</p>
<p>第一个差异CommonJS 输出的是一个值的拷贝</p>
<p>&#x2F;&#x2F; lib.js<br>var counter &#x3D; 3;<br>function incCounter() {<br>   counter++<br>}<br>module.exports &#x3D; {<br>    counter: counter,<br>    incCounter: incCounter<br>}</p>
<p>&#x2F;&#x2F; main,js 里面加载这个模块<br>var mod &#x3D; require(‘.&#x2F;lib’);<br>console.log(mod.counter); &#x2F;&#x2F; 3<br>mod.incCounter();<br>console.log(mod.counter); &#x2F;&#x2F; 3 这里说明 lib.js 模块加载以后， 它的内部变化影响不到输出的 mod.counter 了；<br>除非写成一个函数，才能得到内部变动后的值。</p>
<p>&#x2F;&#x2F; lib.js<br>var counter &#x3D; 3；<br>function incCounter（） {<br>    counter++<br>}<br>module.exports &#x3D; { &#x2F;&#x2F; 此时输出的其实是一个 取值器函数<br>    get counter() {<br>        return counter<br>    },<br>    incCounter: incCounter<br>}</p>
<div></div>

<p>es6 模块的运行机制与CommonJS 不一样。 JS引擎对脚本静态分析的时候，遇到模块加载命令 import，<br>就会生成一个只读的引用。 等到脚本真正执行时，再根据这个只读的引用， 到被加载的哪个模块里面去取值；<br>（es6模块时动态引用，并且不会缓存值， 模块里面的变量绑定其所在的模块）</p>
<p>&#x2F;&#x2F; lib.js<br>export let counter &#x3D; 3；<br>export function incCounter() {<br>    coun3ter++;<br>}</p>
<p>&#x2F;&#x2F; mian.js<br>import {counter, incCounter} from ‘.&#x2F;lib’;<br>console.log(counter); &#x2F;&#x2F; 3<br>incCounter();<br>console.log(counter); &#x2F;&#x2F; 4<br>{}</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/js/" rel="tag"># js</a>
              <a href="/tags/es5/" rel="tag"># es5</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/20/node/" rel="prev" title="node">
      <i class="fa fa-chevron-left"></i> node
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/28/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#script-%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%B1%9E%E6%80%A7%E5%92%8Casync%E5%B1%9E%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">script 标签的defer属性和async属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#defer%E5%92%8Casync%E7%9A%84%E4%B8%BB%E8%A6%81%E4%B8%8D%E5%90%8C%E5%B0%B1%E6%98%AFdefer%E4%BC%9A%E4%BF%9D%E8%AF%81%E8%84%9A%E6%9C%AC%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8Casync%E4%B8%8D%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOMContentLoaded-%EF%BC%8C-onload"><span class="nav-number">2.</span> <span class="nav-text">DOMContentLoaded ， onload</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaowang"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">zhaowang</p>
  <div class="site-description" itemprop="description">病了就要吃药</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/izhaowang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;izhaowang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:izhwang@126.com" title="E-Mail → mailto:izhwang@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhaowang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
